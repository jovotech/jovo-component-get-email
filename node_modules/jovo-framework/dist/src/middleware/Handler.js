"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jovo_core_1 = require("jovo-core");
const _get = require("lodash.get");
const Router_1 = require("./Router");
class Handler {
    /**
     * Calls 'NEW_USER' if the current user is not in the database
     * @param {Jovo} jovo
     * @return {any}
     */
    static async handleOnNewUser(jovo) {
        if (!jovo.$user || !jovo.$user.isNew()) {
            return Promise.resolve();
        }
        jovo_core_1.Log.verbose(jovo_core_1.Log.subheader('NEW_USER'));
        jovo_core_1.Log.verboseStart(' NEW_USER');
        await Handler.handleOnPromise(jovo, _get(jovo.$handlers, jovo_core_1.EnumRequestType.NEW_USER));
        jovo_core_1.Log.verbose();
        jovo_core_1.Log.verboseEnd(' NEW_USER');
        jovo_core_1.Log.verbose();
    }
    /**
     * Calls 'ON_REQUEST' on every request
     * @param {Jovo} jovo
     * @returns {Promise<any>}
     */
    static async handleOnRequest(jovo) {
        jovo_core_1.Log.verbose(jovo_core_1.Log.subheader('ON_REQUEST'));
        jovo_core_1.Log.verboseStart(' ON_REQUEST');
        await Handler.handleOnPromise(jovo, _get(jovo.$handlers, jovo_core_1.EnumRequestType.ON_REQUEST));
        jovo_core_1.Log.verbose();
        jovo_core_1.Log.verboseEnd(' ON_REQUEST');
        jovo_core_1.Log.verbose();
    }
    /**
     * Calls 'NEW_SESSION' if the session is new
     * @param {Jovo} jovo
     * @return {any}
     */
    static async handleOnNewSession(jovo) {
        if (!jovo.isNewSession()) {
            return Promise.resolve();
        }
        jovo_core_1.Log.verbose(jovo_core_1.Log.subheader('NEW_SESSION'));
        jovo_core_1.Log.verboseStart(' NEW_SESSION');
        await Handler.handleOnPromise(jovo, _get(jovo.$handlers, jovo_core_1.EnumRequestType.NEW_SESSION));
        jovo_core_1.Log.verbose();
        jovo_core_1.Log.verboseEnd(' NEW_SESSION');
        jovo_core_1.Log.verbose();
    }
    /**
     * Allows execute logic synchronously and asynchronously
     * Returns Promise when the code inside of the handler is synchronous,
     * executed with a callback function or a promise.
     * @param {Jovo} jovo
     * @param {Function} func
     * @return {Promise<any>}
     */
    static async handleOnPromise(jovo, func) {
        // resolve if there is no ON_REQUEST in the handler
        if (!func) {
            return;
        }
        // resolve if toIntent was triggered before
        if (jovo && jovo.triggeredToIntent) {
            return;
        }
        const params = getParamNames(func);
        // no callback 'done' parameter
        if (params.length < 2) {
            const result = await func.apply(Object.assign(jovo, jovo.$handlers), [jovo]); // tslint:disable-line
            if (typeof result === 'undefined') {
                return;
            }
            else if (result.constructor.name === 'Promise') {
                return result;
            }
            else {
                jovo.triggeredToIntent = true;
                return;
            }
        }
        else {
            return new Promise(resolve => {
                func.apply(Object.assign(jovo, jovo.$handlers), [jovo, resolve]); // tslint:disable-line
            });
        }
    }
    /**
     * Calls the function given in the path.
     * Skips execution when toIntent or toStateIntent are called before.
     *
     * @param {Jovo} jovo
     * @param route
     * @param {Config} config
     * @param {boolean} fromIntent
     * @return {Promise<any>}
     */
    static async applyHandle(jovo, route, fromIntent) {
        // resolve, if toIntent was triggered before
        if (jovo && jovo.triggeredToIntent && !fromIntent) {
            return;
        }
        // set type and path to Unhandled, if no type was matched
        if (!route || typeof route.type === 'undefined') {
            route = {
                path: jovo_core_1.EnumRequestType.UNHANDLED,
                type: jovo_core_1.EnumRequestType.UNHANDLED,
            };
        }
        // end session when type === END and no END handler defined
        if ((route.type === jovo_core_1.EnumRequestType.END || // RequestType is END
            (route.type === jovo_core_1.EnumRequestType.INTENT && // Mapped Intent to END
                route.intent === jovo_core_1.EnumRequestType.END)) &&
            !_get(jovo.$handlers, route.path)) {
            jovo_core_1.Log.verbose('Skip END handler');
            return;
        }
        if (route.type === jovo_core_1.EnumRequestType.AUDIOPLAYER &&
            !_get(jovo.$handlers, route.path)) {
            // @deprecated
            // TODO: Test me
            const v1AudioPlayerPath = route.path.replace('AlexaSkill', 'AudioPlayer');
            if (_get(jovo.$handlers, v1AudioPlayerPath)) {
                route.path = v1AudioPlayerPath;
                jovo_core_1.Log.warn('AudioPlayer.* is deprecated since v2. Please use AlexaSkill.*');
            }
            else {
                return;
            }
        }
        // throw error if no handler and no UNHANDLED on same level
        if (!(_get(jovo.$handlers, jovo_core_1.EnumRequestType.NEW_SESSION) ||
            _get(jovo.$handlers, jovo_core_1.EnumRequestType.NEW_USER) ||
            _get(jovo.$handlers, jovo_core_1.EnumRequestType.ON_REQUEST)) &&
            !_get(jovo.$handlers, route.path)) {
            if (!jovo.$type.optional) {
                throw new jovo_core_1.JovoError(`Could not find the route "${route.path}" in your handler function.`, 'ERR_NO_ROUTE', 'jovo-framework');
            }
        }
        if (_get(jovo.$handlers, route.path)) {
            const func = _get(jovo.$handlers, route.path);
            const params = getParamNames(func);
            // no callback 'done' parameter
            if (params.length < 2) {
                const result = await func.apply(Object.assign(jovo, jovo.$handlers), [jovo]); // tslint:disable-line
                if (typeof result === 'undefined') {
                    return;
                }
                else if (result.constructor.name === 'Promise') {
                    return result;
                }
                else {
                    return;
                }
            }
            else {
                return new Promise(resolve => {
                    func.apply(Object.assign(jovo, jovo.$handlers), [jovo, resolve]); // tslint:disable-line
                });
            }
        }
    }
    install(app) {
        app.middleware('before.router').use((handleRequest) => {
            if (!handleRequest.jovo) {
                return;
            }
            handleRequest.jovo.$handlers = Object.assign(// tslint:disable-line:prefer-object-spread
            {}, handleRequest.app.config.handlers);
            const platform = handleRequest.jovo.getPlatformType();
            if (handleRequest.app.config.plugin[platform] &&
                handleRequest.app.config.plugin[platform].handlers) {
                const platformHandlers = Object.assign(// tslint:disable-line:prefer-object-spread
                {}, handleRequest.app.config.plugin[platform].handlers);
                Object.assign(handleRequest.jovo.$handlers, platformHandlers);
            }
        });
        app.middleware('handler').use(this.handle);
        app.middleware('fail').use(this.error);
        this.mixin(app);
    }
    async handle(handleRequest) {
        if (!handleRequest.jovo) {
            return;
        }
        jovo_core_1.Log.verbose(jovo_core_1.Log.header('Jovo handler ', 'framework'));
        handleRequest.jovo.mapInputs(handleRequest.app.config.inputMap || {});
        const route = handleRequest.jovo.$plugins.Router.route;
        await Handler.handleOnNewUser(handleRequest.jovo);
        await Handler.handleOnNewSession(handleRequest.jovo);
        await Handler.handleOnRequest(handleRequest.jovo);
        jovo_core_1.Log.verbose(jovo_core_1.Log.header('Handle ', 'framework'));
        jovo_core_1.Log.yellow().verbose(route);
        await Handler.applyHandle(handleRequest.jovo, route);
    }
    async error(handleRequest) {
        if (!handleRequest.jovo) {
            jovo_core_1.Log.warn(`WARN: Jovo instance is not available. ON_ERROR doesn't work here`);
            return;
        }
        if (_get(handleRequest.app.config.handlers, jovo_core_1.EnumRequestType.ON_ERROR)) {
            const route = {
                path: jovo_core_1.EnumRequestType.ON_ERROR,
                type: jovo_core_1.EnumRequestType.ON_ERROR,
            };
            await Handler.applyHandle(handleRequest.jovo, route, true);
            await handleRequest.app.middleware('platform.output').run(handleRequest);
            await handleRequest.app.middleware('response').run(handleRequest);
        }
    }
    mixin(app) {
        jovo_core_1.BaseApp.prototype.setHandler = function (...handlers) {
            // tslint:disable-line
            for (const obj of handlers) {
                // eslint-disable-line
                if (typeof obj !== 'object') {
                    throw new Error('Handler must be of type object.');
                }
                this.config.handlers = Object.assign(// tslint:disable-line:prefer-object-spread
                this.config.handlers || {}, obj);
            }
            return this;
        };
        jovo_core_1.Jovo.prototype.triggeredToIntent = false;
        /**
         * Jumps to an intent in the order state > global > unhandled > error
         * @public
         * @param {string} intent name of intent
         */
        jovo_core_1.Jovo.prototype.toIntent = async function (intent) {
            // tslint:disable-line
            this.triggeredToIntent = true;
            const route = Router_1.Router.intentRoute(this.$handlers, this.getState(), intent, this.$app.config.intentsToSkipUnhandled);
            route.from = this.getRoute().from
                ? this.getRoute().from + '/' + this.getRoute().path
                : this.getRoute().path;
            this.$plugins.Router.route = route;
            jovo_core_1.Log.verbose(` toIntent: ${intent}`);
            return Handler.applyHandle(this, route, true);
        };
        jovo_core_1.Jovo.prototype.$handlers = undefined;
        /**
         * Jumps to state intent in the order state > unhandled > error
         * @public
         * @param {string} state name of state
         * @param {string} intent name of intent
         */
        jovo_core_1.Jovo.prototype.toStateIntent = async function (state, intent) {
            // tslint:disable-line
            this.triggeredToIntent = true;
            this.setState(state);
            jovo_core_1.Log.verbose(` Changing state to: ${state}`);
            const route = Router_1.Router.intentRoute(this.$handlers, state, intent, this.$app.config.intentsToSkipUnhandled);
            route.from = this.getRoute().from
                ? this.getRoute().from + '/' + this.getRoute().path
                : this.getRoute().path;
            this.$plugins.Router.route = route;
            jovo_core_1.Log.verbose(` toStateIntent: ${state}.${intent}`);
            return Handler.applyHandle(this, route, true);
        };
        /**
         * Delegates the requests & responses to the component defined with "componentName"
         * @param {string} componentName
         * @param {string} onCompletedIntent intent to which the component will route to after it's done
         * @returns {Promise<void>}
         */
        jovo_core_1.Jovo.prototype.delegate = function (componentName, onCompletedIntent) {
            if (!this.$components[componentName]) {
                throw new jovo_core_1.JovoError(`Couldn\'t find component named ${componentName}`, jovo_core_1.ErrorCode.ERR, 'jovo-framework', 'The component to which you want to delegate to, doesn\'t exist', 'Components are initialized using app.useComponents(...components)', 'TODO jovodocs');
            }
            this.setSessionAttribute(jovo_core_1.SessionConstants.COMPONENT, componentName);
            this.$components[componentName].stateBeforeDelegate = this.getState();
            this.$components[componentName].onCompletedIntent = onCompletedIntent;
            return this.toStateIntent(componentName, 'START');
        };
        /**
         * Jumps from the inside of a state to a global intent
         * @public
         * @param {string} intent name of intent
         */
        jovo_core_1.Jovo.prototype.toStatelessIntent = async function (intent) {
            this.triggeredToIntent = true;
            this.removeState();
            jovo_core_1.Log.verbose(` Removing state.`);
            jovo_core_1.Log.verbose(` toStatelessIntent: ${intent}`);
            return this.toStateIntent(undefined, intent);
        };
        /**
         * Adds state to session attributes
         * @param {string} state
         * @return {Jovo}
         */
        jovo_core_1.Jovo.prototype.followUpState = function (state) {
            return this.setState(state);
        };
        /**
         * Returns path to function inside the handler
         * Examples
         * LAUNCH = Launch function
         * State1:IntentA => IntentA in state 'State1'
         * @public
         * @return {string}
         */
        jovo_core_1.Jovo.prototype.getHandlerPath = function () {
            if (!this.$type || !this.$type.type) {
                return 'No type';
            }
            let path = this.$type.type;
            const route = this.$plugins.Router.route;
            if (this.$type.type === jovo_core_1.EnumRequestType.END && this.$type.subType) {
                path += `: ${this.$type.subType}`;
            }
            if (this.$type.type === jovo_core_1.EnumRequestType.INTENT) {
                path = route.intent;
            }
            if (route.state) {
                path = `${route.state}: ${path}`;
            }
            return path;
        };
        /**
         * Skips intent handling when called in NEW_USER, NEW_SESSION, ON_REQUEST
         * @public
         * @return {*}
         */
        jovo_core_1.Jovo.prototype.skipIntentHandling = async function () {
            this.triggeredToIntent = true;
        };
        /**
         * Returns mapped intent name.
         * @public
         * @return {*}
         */
        jovo_core_1.Jovo.prototype.getMappedIntentName = function () {
            return this.$plugins.Router.route.intent;
        };
        /**
         * Returns route object.
         * @public
         * @return {*}
         */
        jovo_core_1.Jovo.prototype.getRoute = function () {
            return this.$plugins.Router.route;
        };
    }
}
exports.Handler = Handler;
function getParamNames(func) {
    const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
    const ARGUMENT_NAMES = /([^\s,]+)/g;
    const fnStr = func.toString().replace(STRIP_COMMENTS, '');
    let result = fnStr
        .slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')'))
        .match(ARGUMENT_NAMES);
    if (result === null) {
        result = [];
    }
    return result;
}
//# sourceMappingURL=Handler.js.map